<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>November 1, 2015</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/css/global.css"><link rel="stylesheet" href="/diary/css/tomorrow.css"><link rel="stylesheet" href="/diary/css/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>November 1, 2015</h1></header><div class="content"><div class="diary"><h1 id="-javascript-this-1-"><a href="http://www.codeceo.com/article/javascript-this-point.html">图文解说 JavaScript this 到底指向什么？</a></h1>
<p>###转载自来自博客源</p>
<p><code>Frontend</code></p>
<hr>
<p>JavaScript 是一种脚本语言，支持函数式编程、闭包、基于原型的继承等高级功能。JavaScript一开始看起来感觉会很容易入门，但是随着使用的深入，你会发现JavaScript其实很难掌握，有些基本概念让人匪夷所思。其中JavaScript 中的 this 关键字，就是一个比较容易混乱的概念，在不同的场景下，this会化身不同的对象。有一种观点认为，只有正确掌握了 JavaScript 中的 this 关键字，才算是迈入了 JavaScript 这门语言的门槛。在主流的面向对象的语言中（例如Java,C#等)，this 含义是明确且具体的，即指向当前对象。一般在编译期绑定。而 JavaScript 中this 在运行期进行绑定的，这是JavaScript 中this 关键字具备多重含义的本质原因。</p>
<p>JavaScript由于其在运行期进行绑定的特性，JavaScript 中的 this 可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript 中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。常言道，字不如表，表不如图。为了让人更好的理解JavaScript this 到底指向什么？下面用一张图来进行解释：
<img src="http://static.codeceo.com/images/2015/10/d327b5ea4617f048c1e2289500c1ec68.jpg" alt="11"></p>
<p>上图我称之为”JavaScript this决策树“（非严格模式下）。下面通过例子来说明这个图如何来帮助我们对this进行判断：</p>
<pre><code><span class="hljs-keyword">var</span> point = { 
 x : <span class="hljs-number">0</span>, 
 y : <span class="hljs-number">0</span>, 
 moveTo : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span> </span>{ 
     <span class="hljs-keyword">this</span>.x = <span class="hljs-keyword">this</span>.x + x; 
     <span class="hljs-keyword">this</span>.y = <span class="hljs-keyword">this</span>.y + y; 
     } 
 };
<span class="hljs-comment">//决策树解释：point.moveTo(1,1)函数不是new进行调用，进入否决策，</span>
<span class="hljs-comment">//是用dot(.)进行调用，则指向.moveTo之前的调用对象，即point</span>
point.moveTo(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">//this 绑定到当前对象,即point对象</span>
</code></pre><p>point.moveTo（）函数在 “JavaScript this决策树“中进行判定的过程是这样的：</p>
<p>1）point.moveTo函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）point.moveTo函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向point.moveTo中.之前的对象point;</p>
<p>图解point.moveTo函数的this指向什么的解析图如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2015/10/9ccf8959516c09f32167f489af6c273c.jpg" alt="此处输入图片的描述"></p>
<p>再举例，看下面的代码：</p>
<pre><code>function <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x)</span> { </span>
 this.x = x<span class="hljs-comment">; </span>
 } 
<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>; //<span class="hljs-title">this</span>是全局对象<span class="hljs-title">window</span>，<span class="hljs-title">x</span>为全局变量</span>
//决策树解析：<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span>函数是用<span class="hljs-title">new</span>进行调用的么？为否，进入<span class="hljs-title">func</span><span class="hljs-params">()</span>函数是用<span class="hljs-title">dot</span>进行调用的么？为否，则 <span class="hljs-title">this</span>指向全局对象<span class="hljs-title">window</span></span>
x<span class="hljs-comment">;//x =&gt; 5</span>
</code></pre><p>func（）函数在 “JavaScript this决策树“中进行判定的过程是这样的：</p>
<p>1）func(5)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）func(5)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;</p>
<p>图解func函数的this指向什么的解析图如下图所示：</p>
<p><img src="http://static.codeceo.com/images/2015/10/9fbfe54c39fd80b14397f5f8a4b8552a.jpg" alt="此处输入图片的描述"></p>
<p>针对作为函数直接调用的方式，下面看一个复杂的例子：</p>
<pre><code><span class="hljs-keyword">var</span> point = { 
 x : <span class="hljs-number">0</span>, 
 y : <span class="hljs-number">0</span>, 
 moveTo : <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span> </span>{ 
     <span class="hljs-comment">// 内部函数</span>
     <span class="hljs-keyword">var</span> moveX = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> </span>{ 
     <span class="hljs-keyword">this</span>.x = x;<span class="hljs-comment">//this 指向什么？window</span>
    }; 
    <span class="hljs-comment">// 内部函数</span>
    <span class="hljs-keyword">var</span> moveY = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(y)</span> </span>{ 
    <span class="hljs-keyword">this</span>.y = y;<span class="hljs-comment">//this 指向什么？window</span>
    }; 
    moveX(x); 
    moveY(y); 
    } 
 }; 
 point.moveTo(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>); 
 point.x; <span class="hljs-comment">//=&gt;0 </span>
 point.y; <span class="hljs-comment">//=&gt;0 </span>
 x; <span class="hljs-comment">//=&gt;1 </span>
 y; <span class="hljs-comment">//=&gt;1</span>
</code></pre><p>point.moveTo(1,1)函数实际内部调用的是moveX()和moveY()函数, moveX()函数内部的this在 “JavaScript this决策树“中进行判定的过程是这样的：</p>
<p>1）moveX(1)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）moveX(1)函数不是用dot(.)进行调用的，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;</p>
<p>下面看一下作为构造函数调用的例子：</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x,y</span>)</span>{ 
    <span class="hljs-keyword">this</span>.x = x; <span class="hljs-comment">// this ?</span>
    <span class="hljs-keyword">this</span>.y = y; <span class="hljs-comment">// this ?</span>
 }
<span class="hljs-keyword">var</span> np=<span class="hljs-keyword">new</span> Point(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);
np.x;<span class="hljs-comment">//1</span>
<span class="hljs-keyword">var</span> p=Point(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);
p.x;<span class="hljs-comment">//error, p是一个空对象undefined</span>
<span class="hljs-built_in">window</span>.x;<span class="hljs-comment">//2</span>
</code></pre><p>Point(1,1)函数在var np=new Point(1,1)中的this在 “JavaScript this决策树“中进行判定的过程是这样的：</p>
<p>1）var np=new Point(1,1)调用是用new进行调用的么？这个明显是，进入“是”分支，即this指向np；</p>
<p>2）那么this.x=1，即np.x=1；</p>
<p>Point(2,2)函数在var p= Point(2,2)中的this在 “JavaScript this决策树“中进行判定的过程是这样的：</p>
<p>1）var p= Point(2,2)调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）Point(2,2)函数不是用dot(.)进行调用的？判定为否，即进入“否”分支，即这里的this指向全局变量window，那么this.x实际上就是window.x;</p>
<p>3）this.x=2即window.x=2.</p>
<p>最后看一下函数用call 和apply进行调用的例子：</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span><span class="hljs-params">(x, y)</span></span>{ 
    <span class="hljs-keyword">this</span>.x = x; 
    <span class="hljs-keyword">this</span>.y = y; 
    <span class="hljs-keyword">this</span>.moveTo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, y)</span></span>{ 
        <span class="hljs-keyword">this</span>.x = x; 
        <span class="hljs-keyword">this</span>.y = y; 
    } 
 } 

<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); 
<span class="hljs-keyword">var</span> p2 = {x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>}; 
p1.moveTo.apply(p2, [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>]);<span class="hljs-comment">//apply实际上为p2.moveTo(10,10)</span>
p2.x<span class="hljs-comment">//10</span>
</code></pre><p>p1.moveTo.apply(p2,[10,10])函数在 “JavaScript this决策树“中进行判定的过程是这样的：</p>
<p>我们知道，apply 和 call 这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。p1.moveTo.apply(p2,[10,10])实际上是p2.moveTo(10,10)。那么p2.moveTo(10,10)可解释为：</p>
<p>1）p2.moveTo(10,10)函数调用是用new进行调用的么？这个明显不是，进入“否”分支，即函数是否用dot(.)进行调用？；</p>
<p>2）p2.moveTo(10,10)函数是用dot(.)进行调用的，即进入“是”分支，即这里的this指向p2.moveTo(10,10)中.之前的对象p2,所以p2.x=10;</p>
<p>关于JavaScript函数执行环境的过程，IBM developerworks文档库中的一段描述感觉很不错，摘抄如下：</p>
<pre><code>“JavaScript 中的函数既可以被当作普通函数执行，也可以作为对象的方法执行，这是导致 <span class="hljs-keyword">this</span> 含义如此丰富的主要原因。一个函数被执行时，会创建一个执行环境（ExecutionContext），函数的所有的行为均发生在此执行环境中，构建该执行环境时，JavaScript 首先会创建 <span class="hljs-built_in">arguments</span>变量，其中包含调用函数时传入的参数。接下来创建作用域链。然后初始化变量，首先初始化函数的形参表，值为 <span class="hljs-built_in">arguments</span>变量中对应的值，如果 <span class="hljs-built_in">arguments</span>变量中没有对应值，则该形参初始化为 <span class="hljs-literal">undefined</span>。如果该函数中含有内部函数，则初始化这些内部函数。如果没有，继续初始化该函数内定义的局部变量，需要注意的是此时这些变量初始化为 <span class="hljs-literal">undefined</span>，其赋值操作在执行环境（ExecutionContext）创建成功后，函数执行时才会执行，这点对于我们理解 JavaScript 中的变量作用域非常重要，鉴于篇幅，我们先不在这里讨论这个话题。最后为 <span class="hljs-keyword">this</span>变量赋值，如前所述，会根据函数调用方式的不同，赋给 <span class="hljs-keyword">this</span>全局对象，当前对象等。至此函数的执行环境（ExecutionContext）创建成功，函数开始逐行执行，所需变量均从之前构建好的执行环境（ExecutionContext）中读取。”
</code></pre><p>理解这段话对于理解Javascript函数将大有好处。</p>
</div></div><footer class="footer"><address class="author">Copyright &copy; <a rel="author" href="https://github.com/xygcxy" class="author-name">yungeng xu</a>-<a href="https://github.com/xygcxy/my-tech-diary" class="source-repo">Source</a></address><p>Generated by <a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>